回答例
---

#### 設計

* 入力はこれらであると
  * 条件 - カード枚数/操作回数
  * 操作内容
* これらは IO を伴うので、 `String` からモデルへの変換処理が必要そうだ。
* これを `Converter` と名付けよう
* 出力データの状態まではモデルで処理をしよう
* 出力はモデルデータを出力用のデータに変換するオブジェクトが必要そうだ
* これを `Formatter` と名付けよう
* 入力データ・出力データはモデルのデータ構造に依存するので、これらを作るのは後にしよう
* ということで、モデルから作り始めよう

![コンポーネント](http://www.plantuml.com/plantuml/png/SoWkIImgAStDuOhspKz9pObLI2nMyENYYdREpojBBIf9BGABE7D5U_g3MPx-ND5k-KMvYIKmEJSkBby56rrT1MShXSTDcnyt0z64nyrx7ZVj1v6DwnytBthStFwuUVNZfabF-vkUjowFoTF0fdBTq_PTJxjcFzywuTcyEK2DCNa8hOr0jEfnKxScbxE2dfuTq1quRFFqHxO6o6je09giu1ZWgG2KUB9t_-F6nOyRbu7CReVe0wkVzhYfwyK-8BT14-OVDw0DpLCVDwq4AMkUzxYv6R-Nq1GZVDMw5EWhP5sQN6vmJw3fmkaF1Mo-GF53-owmDJF1eUIGcfS2Z5O0)

#### モデル - 1

* どうやらカードの集まりというものがあるらしいので、 `Cards` と名付けよう。
* そこで、 `Cards` クラスではなく、 `CardsTest` クラスを作る。
* `Cards` をシャッフルする方法には、カットとリフルシャッフルという方法があるらしい。
* まずは簡単そうなカットに取り組むことにしよう
* カットの位置は 1 〜 2n - 1 までなので、まず簡単そうな k = 1 の場合のテストを書いてみよう
* テストの名前は `cutAt1` にしよう
* まず、最初のカードの状態を考えよう
* カードは 1 〜 2n までの数字が書かれているらしい。
* n = 1 の場合は特殊っぽいので、それより多くて、でも複雑でない手頃な数として n = 3 のケースをテストしてみよう
* まずカードの集まり `Cards` のインスタンスを作る方法として、並び順に数値を書いていける `Cards.of(int...)` があることにしよう
* ↑ のメソッドに 1 〜 6 を順番に書いて、 `Cards` のインスタンスを取得してみよう
* これに対して `1` でカットしてみよう。メソッド名は `cutAt` でいいかな
* 結果を比較してみよう。 `1` と `2,3,4,5,6` で区切って、上下を入れ替えたのだから、結果は `Cards.of(2,3,4,5,6,1)` となるね
* よしテストを流してみよう。あれ、コンパイルエラーになるね。
* まず `Cards` クラスがないので、 `Cards` クラスを作るよ
* `cutAt(int)` メソッドがないので、 `cutAt(int)` メソッドを作るよ。とりあえず `null` を返すよ
* `of(int...)` メソッドがないので、 `of(int...)` メソッドを作るよ。とりあえず `null` を返すよ
* ヌルポーーーーーーーーーーーーーー
* まずは `of` メソッドが `Cards` のインスタンスを返すようにするよ。 `return new Cards()`
* テスト流すよ。当然、まだ落ちるよ
* `cutAt(int)` が `Cards` のインスタンスを返すようにするよ。 `return new Cards()`
* テスト流すよ。当然、落ちるよ。
* `equals` で比較しているから、 `equals` メソッドを実装するよ。もちろん、一般オブジェクト等価契約 `hashCode` も実装するよ。
  * `equals` : `return obj instanceof Cards`
  * `hashCode` : `return 1`
* テスト通ったね…
* とりあえずコミット
* でも、これ等価性に関して疑問があるね。
* 異なるオブジェクトを比較するテストをしてみよう
* `Cards.of(1,2)` と `Cards.of(2,1)` は異なるオブジェクトなので、等価ではないテストを書いてみよう
* すべてが等価になるように作っているので、テストに失敗だね
* じゃ、まずはファクトリーメソッドに与えている `int...`(配列)を内部に保持するようにして、それの比較にしよう
* 等価性のテストは通ったけど、 `cutAt` のテストに落ちてしまったね
* とりあえず、 `cutAt` のテストは後で修正するとして、 等価性の一致するパターンのテストも試しておこう
* `equality` としたテストの名前を `equality_異なる` に変更して、一致パターンのテストと識別できるようにしよう
* 等価性のテストの一致パターンのテストを追加しよう
* 等価性に関しては問題なさそうなことを確認できた
* で、 `cutAt` のテストに戻って、これが通るような実装を作ろう
* とりあえず、 `1` 枚目を最後尾において、他を順繰りに前に持っていくような実装にしてテストを通そう
* テストが通ったけど、これもまた実装に不安があるよね
* じゃ、入力値を変えてテストしよう
* 次に `cutAt` に `2` を渡すテストを書いてみよう
* 見事に落ちたのだが、何がどう異なっているかわからないね
* 一旦 `toString` を実装しておこう。これは単純に array の中を出力するものでよいだろう
* まあ、案の定カードの位置がことなっているよね
* パラメーターの `position` の位置に応じた処理が必要だね
* 後ろに持っていくのは `position - 1` のインデックスを持つカードより前にあるカード、一番先頭になるのはインデックスが `positon` のカードだよね
* あとは数字を適当に調整
* はい。テストが通りましたね
* カード枚数が異なる場合も気になるので、テストを書いてみよう
* どうやら大丈夫っぽいけど…
* カード枚数は `n` の形で入ってくるのに対して、いちいち `1,2,3,...,2n` とパラメーターを作るのがそろそろ面倒だね
* `n` を渡したら、 `2n` のカードが帰ってくる `twoTimes(int)` メソッドを作ろう
* まず `Cards.twoTimes(3)` は `Cards.of(1,2,3,4,5,6)` と等しくなることをテストしよう
* いつもどおり、適当に実装を作ってコンパイルを通してテストが落ちるのを確認
* 1　から 2n までの配列を作ってコンストラクターにわたすように修正、テストを実行する
* `cutAt` はだいたい実装が終わったので、 リフルシャッフル(`reFullShuffle`)の実装に移る
* また、前回と同様にテストから書きはじめる
* リフルシャッフルは 1 〜 n 枚目のグループ(A)と n + 1 〜 n + n 枚目のグループ(B)に分けて、 A -> B -> A -> B ... の順番に上のカードをマージしていくので、予想される結果は 1,4,2,5,3,6 になる
* もちろん、コンパイルエラーになる
* コンパイルエラーを解消して、テストを再実行
* まあ、当然ですがテストは落ちますよね
* 適切な実装にして、テストを再実行。テストは通ったね
* テスト1件だけでは不安だね。じゃあ、別のケースのテストを書こう
* テストの結果を想像しやすい、 20件のデータパターンのテストを追加したよ
* …もちろん通過したね

### モデル - 2

* カードの束のモデルはできたので、今度は操作のモデルを作ってくよ
* 操作にはカットとリフルシャッフルの二つがあったのは確認済みだね
* なので、それぞれの操作をモデル化するよ
* え？入力値から操作の内容はわかるのだから、入力値に応じて `if` 文で先程作った `Cards` のメソッドの呼び出しを切り替えればいいって？
* それだと、入力(IO) とモデルの結びつきが強くなってしまうね
  * 操作のモデルクラスを作って、そのオブジェクトが `Cards` を操作する形にすると、このアプリケーションのロジックすべてをモデルで表現できる
  * すると、入力に依存しなくなるので、このアプリケーションを模擬的に動かせるようになるので、あれこれ実験もできるし、当然テストも行いやすくなる
  * なぜなら、自分たちがつくったコードそのものだけで動かせるからね
  * だけど入力(IO)を受けてから `if` 文で分岐させる形にしてしまうと、このアプリケーションを動かすためには入力(IO)が必要になってしまうし、そうなるとテストを実行する難易度もあがる
* じゃあ入力(IO)を受け取ってから `Cards` の操作をするまではどうするのかって？
* それは入力をモデルに変換する層でモデルに作り変えればよいわけですよ
* では、早速 `Operation` というインターフェースを考えるよ
* `Operation` インターフェースは `Cards` を受け取って、 `Cards` に変換するインターフェースだね
